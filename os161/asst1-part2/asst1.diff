diff --git a/kern/asst1/stoplight.c b/kern/asst1/stoplight.c
index 073ed3c..92d9eac 100644
--- a/kern/asst1/stoplight.c
+++ b/kern/asst1/stoplight.c
@@ -17,6 +17,16 @@
 #include <lib.h>
 #include <test.h>
 #include <thread.h>
+#include <machine/spl.h>
+#include <curthread.h>
+#include <synch.h>
+
+int vehicleCount;
+struct lock *AB, *BC, *CA, *completionLock;
+unsigned long curNum;
+
+
+
 
 
 /*
@@ -69,13 +79,33 @@ turn_left(unsigned long vehiclenumber)
 
 static
 void
-turn_right(unsigned long vehiclenumber)
-{
+turn_right(unsigned long vehiclenumber, int route){
+	//kprintf("\nTurned right\n");
+	lock_acquire(AB);
+	if(lock_do_i_hold(AB) == 1){
+		//kprintf("\nentering\n");
+		enter(vehiclenumber, route);
+		if(route == 0){ //starting a turning r
+			
+			leave(vehiclenumber, 0);
+		}
+		else if(route == 1){ //starting b turning r
+			
+			leave(vehiclenumber, 1);
+		}
+		else{ //starting c turning r
+			
+			leave(vehiclenumber, 2);
+		}
+	}
+	lock_release(AB);
+	vehicleCount ++;
+
 	/*
 	 * Avoid unused variable warnings.
 	 */
 
-	(void) vehiclenumber;
+	//(void) vehiclenumber;
 }
 
 
@@ -110,10 +140,22 @@ vehicle_thread(void * unusedpointer,
 	 * Avoid unused variable and function warnings.
 	 */
 	(void) unusedpointer;
-	(void) vehiclenumber;
+	//(void) vehiclenumber;
 
 	(void) turn_left;
-	(void) turn_right;
+	//(void) turn_right;
+	curNum = vehiclenumber;
+	int direction = get_vehicle_turn_direction(vehiclenumber);
+	int route = get_vehicle_route(vehiclenumber);
+	//int type = get_vehicle_type(vehiclenumber);
+	approach(vehiclenumber);
+	if(direction == 0){
+		turn_right(vehiclenumber, route);
+	}
+	
+
+
+
 
 	/* Note: Throughout this project you will use the get_vehicle_* functions
 	 * to get various information about the vehicle. For example:
@@ -152,6 +194,14 @@ int
 stoplight_driver(int vehicle_count)
 {
 	int index, error;
+	vehicleCount = 0;
+        AB = lock_create("AB");
+	BC = lock_create("BC");
+	CA = lock_create("CA");
+	completionLock = lock_create("completion_lock");
+
+
+
 
 	for (index = 0; index < vehicle_count; index++) {
 
@@ -173,7 +223,17 @@ stoplight_driver(int vehicle_count)
 				 );
 		}
 	}
-
+/**
+	while (vehicleCount != vehicle_count) {
+		lock_acquire(completionLock);
+		if (vehicleCount >= vehicle_count) {
+			lock_release(completionLock);
+			break;
+		}
+		lock_release(completionLock);
+	}
+	
+**/
 	/* This function indicates the end of the stoplight problem.
 	 * This kind of thing is important in a synchronization problem, as
 	 * without a specific indicator that the problem has been concluded,
@@ -186,6 +246,11 @@ stoplight_driver(int vehicle_count)
 	 * Note that deleting the call to finish() will not score you any points. You
 	 * must correctly synchronize it to get credit for that part of the project.
 	 */
+	
+	lock_destroy(AB);
+	lock_destroy(BC);
+	lock_destroy(CA);
+	lock_destroy(completionLock);
 	finish();
 
 	return 0;
diff --git a/kern/include/synch.h b/kern/include/synch.h
index af890e4..42b0b21 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -51,6 +51,9 @@ void              sem_destroy(struct semaphore *);
 struct lock {
 	char *name;
 	struct thread * volatile current_holder;
+	volatile unsigned long vehicleNum;
+	volatile int lock_held;
+	struct queue * waiting_threads;
 	// add what you need here
 	// (don't forget to mark things volatile as needed)
 };
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 4c33942..219af64 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -9,11 +9,16 @@
 #include <thread.h>
 #include <curthread.h>
 #include <machine/spl.h>
-
+#include <queue.h>
 ////////////////////////////////////////////////////////////
 //
 // Semaphore.
 
+
+
+
+
+
 struct semaphore *
 sem_create(const char *namearg, int initial_count)
 {
@@ -98,11 +103,14 @@ V(struct semaphore *sem)
 //
 // Lock.
 
+
+
+
 struct lock *
 lock_create(const char *name)
 {
 	struct lock *lock;
-
+	kprintf("\nHEY IM HERE!\n");
 	lock = kmalloc(sizeof(struct lock));
 	if (lock == NULL) {
 		return NULL;
@@ -115,47 +123,83 @@ lock_create(const char *name)
 	}
 	
 	// add stuff here as needed
-	
+	lock->waiting_threads = q_create(1);
+	lock->lock_held = 0;
+	lock->current_holder = NULL;
 	return lock;
 }
 
 void
 lock_destroy(struct lock *lock)
 {
+	int spl = splhigh();
 	assert(lock != NULL);
+	assert(lock->current_holder == NULL);
+	
+	//assert(isVehicleQueueEmpty(lock->waiting_threads));
+
+    	//destroyVehicleQueue(lock->waiting_threads);
+
+	//assert(lock != NULL);
 
 	// add stuff here as needed
-	
+	q_destroy(lock->waiting_threads);
+	kfree(lock->waiting_threads);	
 	kfree(lock->name);
 	kfree(lock);
+
+	splx(spl);
 }
 
 void
 lock_acquire(struct lock *lock)
 {
-	// Write this
+	assert(lock != NULL);
+	int spl = splhigh();
+	int lockQueued = 0;
+	assert(!lock_do_i_hold(lock));
+	while(lock->lock_held == 1){
+		if (lockQueued == 0){
+			q_addtail(lock->waiting_threads, curthread);
+			//q_grow(lock->waiting_threads,lock->waiting_threads->size+1 );
+
+			lockQueued ++;
+		}
+		thread_sleep(q_getguy(lock->waiting_threads,q_getend(lock->waiting_threads)));
+	}
+	lock->lock_held = 1;
+	lock->current_holder = curthread;
+	splx(spl);
 
-	(void)lock;  // suppress warning until code gets written
+	//kprintf("\nLOCK ACQUIRED!\n");
 }
 
 void
 lock_release(struct lock *lock)
 {
-	// Write this
-
-	(void)lock;  // suppress warning until code gets written
+	int spl = splhigh();
+	assert(lock != NULL);
+	assert(lock->lock_held && (lock->current_holder == curthread));
+	lock->lock_held = 0;
+	lock->current_holder = NULL;
+	thread_wakeup(q_getguy(lock->waiting_threads,q_getstart(lock->waiting_threads)));
+	q_remhead(lock->waiting_threads);
+	splx(spl);	
 }
 
 int
 lock_do_i_hold(struct lock *lock)
 {
+	assert(lock != NULL);
+	return (lock->lock_held && (lock->current_holder == curthread));
 	// Write this
 
-	(void)lock;  // suppress warning until code gets written
+	//(void)lock;  // suppress warning until code gets written
 
-	return 1;    // dummy until code gets written
+	//return 0;    // dummy until code gets written
 }
 
+
 ////////////////////////////////////////////////////////////
 //
 // CV
diff --git a/sys161-default.conf b/sys161-default.conf
index 930fb69..b239f5c 100644
--- a/sys161-default.conf
+++ b/sys161-default.conf
@@ -115,7 +115,7 @@
 
 #27	nic hwaddr=1
 
-28	random	autoseed
+28	random	autoseed =1
 29	timer
 30	trace
 # Note: Maximum possible ram is 16 megabytes (16777216).
